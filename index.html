<!doctype html>
<html lang="pt">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1"/>
  <title>Jogo: Pólos e Zeros no Plano-s</title>
  <style>
    :root { --bg:#0b0e14; --panel:#121827; --text:#e7eefc; --muted:#a9b7d0; --accent:#7aa2ff; --ok:#4ade80; --bad:#fb7185; }
    body { margin:0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    .wrap { max-width: 1100px; margin: 0 auto; padding: 18px; display: grid; grid-template-columns: 1.1fr 0.9fr; gap: 16px; }
    .card { background: var(--panel); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; padding: 14px; box-shadow: 0 8px 24px rgba(0,0,0,.35); }
    h1 { font-size: 18px; margin: 0 0 10px; }
    h2 { font-size: 14px; margin: 0 0 10px; color: var(--muted); font-weight: 600; letter-spacing: .2px; }
    .row { display: flex; gap: 10px; flex-wrap: wrap; align-items: center; }
    .btn {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.10);
      color: var(--text);
      border-radius: 10px;
      padding: 8px 10px;
      cursor: pointer;
      font-weight: 600;
    }
    .btn:hover { border-color: rgba(122,162,255,0.55); }
    .btn.primary { background: rgba(122,162,255,0.18); border-color: rgba(122,162,255,0.35); }
    .btn.tool { min-width: 120px; text-align: center; }
    .btn.on { outline: 2px solid rgba(122,162,255,0.7); }
    .btn.good { background: rgba(74,222,128,0.14); border-color: rgba(74,222,128,0.35); }
    .btn.bad { background: rgba(251,113,133,0.14); border-color: rgba(251,113,133,0.35); }
    select, input[type="checkbox"] { accent-color: var(--accent); }
    .mono { font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace; }
    .H { font-size: 14px; line-height: 1.45; padding: 10px; border-radius: 12px; background: rgba(0,0,0,0.22); border: 1px solid rgba(255,255,255,0.08); }
    canvas { width: 100%; height: auto; border-radius: 12px; background: rgba(0,0,0,0.25); border: 1px solid rgba(255,255,255,0.10); }
    .small { font-size: 12px; color: var(--muted); }
    .status { padding: 10px; border-radius: 12px; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.04); }
    .status.ok { border-color: rgba(74,222,128,0.35); background: rgba(74,222,128,0.08); }
    .status.bad { border-color: rgba(251,113,133,0.35); background: rgba(251,113,133,0.08); }
    .pill { display:inline-block; padding: 2px 8px; border-radius: 999px; background: rgba(255,255,255,0.08); border:1px solid rgba(255,255,255,0.10); font-size: 12px; color: var(--muted); }
    .grid2 { display:grid; grid-template-columns: 1fr 1fr; gap: 10px; }
    .hr { height: 1px; background: rgba(255,255,255,0.08); margin: 12px 0; }
    @media (max-width: 980px) { .wrap { grid-template-columns: 1fr; } }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="card">
      <h1>Jogo: Colocar Pólos e Zeros no Plano-s</h1>
      <div class="row">
        <label class="pill">Nível
          <select id="levelSel">
            <option value="1">Nível 1 — raízes reais</option>
            <option value="2">Nível 2 — inclui par complexo conjugado</option>
            <option value="3">Nível 3 — inclui multiplicidade</option>
          </select>
        </label>
        <button class="btn primary" id="newBtn">Nova H(s)</button>
        <button class="btn" id="resetBtn">Limpar marcações</button>
        <button class="btn" id="undoBtn">Desfazer</button>
        <label class="pill">
          <input type="checkbox" id="teacherMode"> modo professor (mostrar solução)
        </label>
      </div>

      <div class="hr"></div>

      <h2>Função de transferência (já fatorizada)</h2>
      <div class="H mono" id="Hdisp"></div>
      <p class="small">
        Dica: zeros vêm do numerador e pólos do denominador. Em sistemas contínuos, estabilidade BIBO exige
        <b>todos os pólos</b> com <b>Re(s) &lt; 0</b> (sem pólos no eixo imaginário).
      </p>

      <div class="hr"></div>

      <h2>Plano-s</h2>
      <canvas id="c" width="900" height="560" aria-label="Plano-s"></canvas>

      <div class="row" style="margin-top:10px;">
        <button class="btn tool on" id="toolZero">Ferramenta: Zero (○)</button>
        <button class="btn tool" id="toolPole">Ferramenta: Pólo (×)</button>
        <span class="pill" id="countPill">zeros: 0/0 · pólos: 0/0</span>
      </div>

      <div class="hr"></div>

      <div class="row">
        <button class="btn primary" id="checkBtn">Verificar colocação</button>
        <span class="small">Tolerância: ±0.35 em Re/Im</span>
      </div>

      <div id="placeFeedback" class="status" style="margin-top:10px;">
        Coloca as marcações clicando no plano-s. (No nível 1, a parte imaginária é forçada a 0.)
      </div>

      <div class="hr"></div>

      <h2>Pergunta de estabilidade (após verificar)</h2>
      <div class="row">
        <button class="btn" id="stabYes" disabled>Sim, é estável</button>
        <button class="btn" id="stabNo" disabled>Não, é instável</button>
      </div>
      <div id="stabFeedback" class="status" style="margin-top:10px;">
        Primeiro verifica a colocação. Depois responde à estabilidade.
      </div>
    </div>

    <div class="card">
      <h2>Objetivo pedagógico</h2>
      <p class="small">
        Treinar o “vai-e-vem” entre a expressão fatorizada e a interpretação geométrica no plano-s:
        <b>ler raízes → mapear pontos → inferir estabilidade pelos pólos</b>.
      </p>

      <div class="grid2">
        <div class="status">
          <b>Nível 1</b><br>
          <span class="small">Associação direta entre fatores lineares reais e pontos no eixo real.</span>
        </div>
        <div class="status">
          <b>Nível 2</b><br>
          <span class="small">Reconhecimento de pares conjugados e simetria relativamente ao eixo real.</span>
        </div>
        <div class="status">
          <b>Nível 3</b><br>
          <span class="small">Multiplicidade: duas marcações no mesmo ponto (impacto em dinâmica/ordem).</span>
        </div>
      </div>

      <div class="hr"></div>

      <h2>Como o jogo avalia</h2>
      <ul class="small">
        <li>Confere se o aluno colocou o <b>número certo</b> de zeros e pólos.</li>
        <li>Faz “matching” por proximidade (tolerância ±0.35).</li>
        <li>Depois pergunta estabilidade: <b>Re(pólo)&lt;0</b> para todos.</li>
      </ul>

      <div class="hr"></div>

      <h2>Extensões rápidas (se quiseres)</h2>
      <ul class="small">
        <li>Adicionar resposta em frequência (Bode) e ligar “pólos perto do eixo jω” a ressonâncias.</li>
        <li>Adicionar modo discreto (plano-z) com critério do círculo unitário.</li>
        <li>Adicionar “raízes no eixo imaginário” para discutir estabilidade marginal.</li>
      </ul>

      <div class="hr"></div>

      <div class="status">
        <b>Nota</b><br>
        <span class="small">
          A estabilidade aqui é a BIBO para sistemas contínuos com H(s) racional.
          Para modelos com cancelamentos “perfeitos” ou não-mínima fase, há nuances, mas para um jogo introdutório
          este critério é o mais didático.
        </span>
      </div>
    </div>
  </div>

<script>
(() => {
  // =========================
  // Config do "plano-s"
  // =========================
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  // Janela do plano-s (Re e Im)
  const VIEW = { xmin: -8, xmax: 8, ymin: -6, ymax: 6 };
  const TOL = 0.35;

  const levelSel = document.getElementById('levelSel');
  const Hdisp = document.getElementById('Hdisp');
  const countPill = document.getElementById('countPill');

  const newBtn = document.getElementById('newBtn');
  const resetBtn = document.getElementById('resetBtn');
  const undoBtn = document.getElementById('undoBtn');
  const checkBtn = document.getElementById('checkBtn');

  const toolZero = document.getElementById('toolZero');
  const toolPole = document.getElementById('toolPole');

  const placeFeedback = document.getElementById('placeFeedback');
  const stabYes = document.getElementById('stabYes');
  const stabNo = document.getElementById('stabNo');
  const stabFeedback = document.getElementById('stabFeedback');

  const teacherMode = document.getElementById('teacherMode');

  let tool = 'zero'; // 'zero' | 'pole'

  // Estado do exercício
  let expectedZeros = []; // [{re, im}]
  let expectedPoles = []; // [{re, im}]
  let userZeros = [];
  let userPoles = [];
  let lastPlacedStack = []; // para undo: {type, idx}

  let verifiedPlacement = false;
  let systemIsStable = null;

  // =========================
  // Utilitários
  // =========================
  const rnd = (a,b) => a + Math.random()*(b-a);
  const choice = arr => arr[Math.floor(Math.random()*arr.length)];
  const nearly = (a,b,eps) => Math.abs(a-b) <= eps;

  function toCanvas(re, im) {
    const x = (re - VIEW.xmin) / (VIEW.xmax - VIEW.xmin) * canvas.width;
    const y = (VIEW.ymax - im) / (VIEW.ymax - VIEW.ymin) * canvas.height;
    return {x,y};
  }

  function toPlane(px, py) {
    const re = VIEW.xmin + (px / canvas.width) * (VIEW.xmax - VIEW.xmin);
    const im = VIEW.ymax - (py / canvas.height) * (VIEW.ymax - VIEW.ymin);
    return {re, im};
  }

  function fmtNum(x) {
    // Formato simples e legível
    const r = Math.round(x*100)/100;
    return (r >= 0 ? r.toString() : r.toString());
  }

  function fmtFactor(root) {
    const {re, im} = root;
    // (s - (a + jb)) e (s - r) para real
    if (Math.abs(im) < 1e-9) {
      // (s - re) => (s + |re|) se re negativo
      if (re < 0) return `(s + ${fmtNum(Math.abs(re))})`;
      if (re > 0) return `(s - ${fmtNum(re)})`;
      return `(s)`; // evitamos gerar 0, mas por segurança
    } else {
      const sign = im >= 0 ? '+' : '-';
      return `(s - (${fmtNum(re)} ${sign} j${fmtNum(Math.abs(im))}))`;
    }
  }

  function buildFactorString(K, zeros, poles) {
    // zeros/poles vêm como lista COM multiplicidade (repetições)
    const num = zeros.length ? zeros.map(fmtFactor).join('') : '1';
    const den = poles.length ? poles.map(fmtFactor).join('') : '1';
    return `H(s) = ${fmtNum(K)} · ${num} / ${den}`;
  }

  function setTool(next) {
    tool = next;
    toolZero.classList.toggle('on', tool==='zero');
    toolPole.classList.toggle('on', tool==='pole');
  }

  function updateCounts() {
    countPill.textContent = `zeros: ${userZeros.length}/${expectedZeros.length} · pólos: ${userPoles.length}/${expectedPoles.length}`;
  }

  function clearPlacementUI() {
    verifiedPlacement = false;
    stabYes.disabled = true;
    stabNo.disabled = true;
    placeFeedback.className = 'status';
    placeFeedback.textContent = 'Coloca as marcações clicando no plano-s. (No nível 1, a parte imaginária é forçada a 0.)';
    stabFeedback.className = 'status';
    stabFeedback.textContent = 'Primeiro verifica a colocação. Depois responde à estabilidade.';
  }

  // =========================
  // Geração de exercícios
  // =========================
  function genRealRoot(allowNearZero=false) {
    // Evitar valores demasiado perto de 0 para não confundir com eixo
    let r;
    do {
      r = Math.round(rnd(-6, 6) * 2) / 2; // passos de 0.5
    } while (!allowNearZero && Math.abs(r) < 0.6);
    return {re: r, im: 0};
  }

  function genComplexPair() {
    // a pode ser negativo ou positivo; b sempre >0
    let a;
    do { a = Math.round(rnd(-4.5, 4.5)*2)/2; } while (Math.abs(a) < 0.6);
    const b = Math.round(rnd(1.0, 4.0)*2)/2;
    return [{re:a, im:b}, {re:a, im:-b}];
  }

  function generateSystem(level) {
    // reset arrays
    expectedZeros = [];
    expectedPoles = [];

    // Ganho simples
    const K = choice([0.5, 1, 2, 3]);

    // Escolhas típicas: mais pólos que zeros
    if (level === 1) {
      const np = choice([2,3,4]);
      const nz = choice([1,2, Math.max(1, np-2)]);
      const poles = [];
      const zeros = [];
      // gerar pólos reais (alguns podem cair em Re>0 para instabilidade)
      for (let i=0;i<np;i++) poles.push(genRealRoot());
      for (let i=0;i<nz;i++) zeros.push(genRealRoot(true));
      expectedPoles = poles;
      expectedZeros = zeros;
      return {K};
    }

    if (level === 2) {
      // incluir um par complexo conjugado (nos pólos ou zeros)
      const complexIn = choice(['poles','zeros']);
      const poles = [];
      const zeros = [];

      // 1 par complexo
      const pair = genComplexPair();
      if (complexIn === 'poles') poles.push(...pair);
      else zeros.push(...pair);

      // completar com raízes reais
      const np = choice([3,4,5]); // contando o par como 2
      const nz = choice([1,2,3]);
      while (poles.length < np) poles.push(genRealRoot());
      while (zeros.length < nz) zeros.push(genRealRoot(true));

      expectedPoles = poles;
      expectedZeros = zeros;
      return {K};
    }

    // level 3: multiplicidade (pólo duplo e/ou zero duplo)
    if (level === 3) {
      const poles = [];
      const zeros = [];

      // incluir pelo menos um elemento duplo
      const doubleType = choice(['pole','zero','both']);

      // Base: pode incluir também um par conjugado para enriquecer
      const includeComplex = Math.random() < 0.6;
      if (includeComplex) {
        // garantir conjugado nos pólos para reforçar ligação a estabilidade
        poles.push(...genComplexPair());
      }

      // Pólos reais base
      const baseNp = choice([3,4,5]); // incluindo complexos (2)
      while (poles.length < baseNp) poles.push(genRealRoot());

      // Zeros base
      const baseNz = choice([2,3]);
      while (zeros.length < baseNz) zeros.push(genRealRoot(true));

      // aplicar multiplicidade
      if (doubleType === 'pole' || doubleType === 'both') {
        const rp = genRealRoot();
        poles.push(rp); poles.push(rp); // duplicar no mesmo ponto
      }
      if (doubleType === 'zero' || doubleType === 'both') {
        const rz = genRealRoot(true);
        zeros.push(rz); zeros.push(rz);
      }

      expectedPoles = poles;
      expectedZeros = zeros;
      return {K};
    }
  }

  // =========================
  // Estabilidade (contínuo)
  // =========================
  function computeStability() {
    // Critério BIBO: todos os pólos com Re < 0
    for (const p of expectedPoles) {
      if (!(p.re < 0)) return false;
    }
    return true;
  }

  // =========================
  // Matching / verificação
  // =========================
  function matchSets(expected, actual) {
    // expected e actual: arrays de {re, im}
    // devolve {ok:boolean, unmatchedExpected, unmatchedActual}
    const used = new Array(actual.length).fill(false);
    const unmatchedExpected = [];

    for (const e of expected) {
      let bestIdx = -1;
      let bestD = Infinity;
      for (let i=0;i<actual.length;i++) {
        if (used[i]) continue;
        const a = actual[i];
        const d = Math.hypot(e.re - a.re, e.im - a.im);
        if (d < bestD) { bestD = d; bestIdx = i; }
      }
      if (bestIdx >= 0 && bestD <= TOL) {
        used[bestIdx] = true;
      } else {
        unmatchedExpected.push(e);
      }
    }

    const unmatchedActual = [];
    for (let i=0;i<actual.length;i++) if (!used[i]) unmatchedActual.push(actual[i]);

    return {
      ok: unmatchedExpected.length === 0 && unmatchedActual.length === 0,
      unmatchedExpected,
      unmatchedActual
    };
  }

  function verifyPlacement() {
    const mz = matchSets(expectedZeros, userZeros);
    const mp = matchSets(expectedPoles, userPoles);

    const rightCount = (userZeros.length === expectedZeros.length) && (userPoles.length === expectedPoles.length);

    if (!rightCount) {
      verifiedPlacement = false;
      placeFeedback.className = 'status bad';
      placeFeedback.textContent = `Ainda não. Tens de colocar exatamente ${expectedZeros.length} zeros e ${expectedPoles.length} pólos.`;
      stabYes.disabled = true;
      stabNo.disabled = true;
      draw();
      return;
    }

    if (mz.ok && mp.ok) {
      verifiedPlacement = true;
      placeFeedback.className = 'status ok';
      placeFeedback.textContent = '✅ Colocação correta! Agora responde: o sistema é estável?';
      stabYes.disabled = false;
      stabNo.disabled = false;
      systemIsStable = computeStability();
    } else {
      verifiedPlacement = false;
      placeFeedback.className = 'status bad';
      placeFeedback.textContent = '❌ Há marcações deslocadas (ou duplicações em falta). Ajusta e tenta outra vez.';
      stabYes.disabled = true;
      stabNo.disabled = true;
    }

    draw();
  }

  // =========================
  // Desenho
  // =========================
  function drawGrid() {
    ctx.clearRect(0,0,canvas.width,canvas.height);

    // Fundo
    ctx.fillStyle = 'rgba(0,0,0,0.15)';
    ctx.fillRect(0,0,canvas.width,canvas.height);

    // Grelha
    ctx.strokeStyle = 'rgba(255,255,255,0.08)';
    ctx.lineWidth = 1;

    const xStep = 1;
    const yStep = 1;

    for (let x = Math.ceil(VIEW.xmin); x <= VIEW.xmax; x += xStep) {
      const p1 = toCanvas(x, VIEW.ymin);
      const p2 = toCanvas(x, VIEW.ymax);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    for (let y = Math.ceil(VIEW.ymin); y <= VIEW.ymax; y += yStep) {
      const p1 = toCanvas(VIEW.xmin, y);
      const p2 = toCanvas(VIEW.xmax, y);
      ctx.beginPath();
      ctx.moveTo(p1.x, p1.y);
      ctx.lineTo(p2.x, p2.y);
      ctx.stroke();
    }

    // Eixos
    ctx.strokeStyle = 'rgba(122,162,255,0.55)';
    ctx.lineWidth = 2;

    const xAxis1 = toCanvas(VIEW.xmin, 0);
    const xAxis2 = toCanvas(VIEW.xmax, 0);
    ctx.beginPath();
    ctx.moveTo(xAxis1.x, xAxis1.y);
    ctx.lineTo(xAxis2.x, xAxis2.y);
    ctx.stroke();

    const yAxis1 = toCanvas(0, VIEW.ymin);
    const yAxis2 = toCanvas(0, VIEW.ymax);
    ctx.beginPath();
    ctx.moveTo(yAxis1.x, yAxis1.y);
    ctx.lineTo(yAxis2.x, yAxis2.y);
    ctx.stroke();

    // Labels básicos
    ctx.fillStyle = 'rgba(231,238,252,0.9)';
    ctx.font = '14px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
    ctx.fillText('Re(s)', canvas.width - 70, xAxis2.y - 8);
    ctx.fillText('Im(s)', yAxis2.x + 8, 20);
  }

  function drawZero(pt, double=false, alpha=1) {
    const {x,y} = toCanvas(pt.re, pt.im);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(231,238,252,0.95)';
    ctx.lineWidth = 3;

    ctx.beginPath();
    ctx.arc(x, y, 10, 0, Math.PI*2);
    ctx.stroke();

    if (double) {
      ctx.beginPath();
      ctx.arc(x, y, 15, 0, Math.PI*2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function drawPole(pt, double=false, alpha=1) {
    const {x,y} = toCanvas(pt.re, pt.im);
    ctx.save();
    ctx.globalAlpha = alpha;
    ctx.strokeStyle = 'rgba(231,238,252,0.95)';
    ctx.lineWidth = 3;

    const r = 10;
    ctx.beginPath();
    ctx.moveTo(x-r, y-r);
    ctx.lineTo(x+r, y+r);
    ctx.moveTo(x-r, y+r);
    ctx.lineTo(x+r, y-r);
    ctx.stroke();

    if (double) {
      const r2 = 15;
      ctx.beginPath();
      ctx.moveTo(x-r2, y-r2);
      ctx.lineTo(x+r2, y+r2);
      ctx.moveTo(x-r2, y+r2);
      ctx.lineTo(x+r2, y-r2);
      ctx.stroke();
    }

    ctx.restore();
  }

  function multiplicityMap(arr) {
    // devolve map "re,im" -> count
    const m = new Map();
    for (const p of arr) {
      const k = `${Math.round(p.re*100)/100},${Math.round(p.im*100)/100}`;
      m.set(k, (m.get(k)||0) + 1);
    }
    return m;
  }

  function draw() {
    drawGrid();

    // Desenhar marcações do utilizador
    const zMap = multiplicityMap(userZeros);
    const pMap = multiplicityMap(userPoles);

    // Para desenhar "duplo" quando repetido no mesmo ponto
    for (const [k, count] of zMap.entries()) {
      const [re, im] = k.split(',').map(Number);
      drawZero({re, im}, count>=2, 1);
      if (count > 2) {
        // desenhar extra como texto pequeno
        const {x,y} = toCanvas(re, im);
        ctx.fillStyle = 'rgba(231,238,252,0.85)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.fillText(`×${count}`, x+16, y-12);
      }
    }
    for (const [k, count] of pMap.entries()) {
      const [re, im] = k.split(',').map(Number);
      drawPole({re, im}, count>=2, 1);
      if (count > 2) {
        const {x,y} = toCanvas(re, im);
        ctx.fillStyle = 'rgba(231,238,252,0.85)';
        ctx.font = '12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace';
        ctx.fillText(`×${count}`, x+16, y-12);
      }
    }

    // Modo professor: desenhar solução a baixa opacidade
    if (teacherMode.checked) {
      const ezMap = multiplicityMap(expectedZeros);
      const epMap = multiplicityMap(expectedPoles);

      for (const [k, count] of ezMap.entries()) {
        const [re, im] = k.split(',').map(Number);
        drawZero({re, im}, count>=2, 0.25);
      }
      for (const [k, count] of epMap.entries()) {
        const [re, im] = k.split(',').map(Number);
        drawPole({re, im}, count>=2, 0.25);
      }
    }
  }

  // =========================
  // Interação do utilizador
  // =========================
  canvas.addEventListener('click', (ev) => {
    const rect = canvas.getBoundingClientRect();
    const px = (ev.clientX - rect.left) * (canvas.width / rect.width);
    const py = (ev.clientY - rect.top) * (canvas.height / rect.height);
    let {re, im} = toPlane(px, py);

    // Nível 1: forçar Im = 0
    if (Number(levelSel.value) === 1) im = 0;

    // arredondar ligeiramente para evitar ruído e facilitar correspondência
    re = Math.round(re*100)/100;
    im = Math.round(im*100)/100;

    if (tool === 'zero') {
      if (userZeros.length >= expectedZeros.length) {
        placeFeedback.className = 'status bad';
        placeFeedback.textContent = 'Já colocaste o número máximo de zeros para este exercício.';
        return;
      }
      userZeros.push({re, im});
      lastPlacedStack.push({type:'zero'});
    } else {
      if (userPoles.length >= expectedPoles.length) {
        placeFeedback.className = 'status bad';
        placeFeedback.textContent = 'Já colocaste o número máximo de pólos para este exercício.';
        return;
      }
      userPoles.push({re, im});
      lastPlacedStack.push({type:'pole'});
    }

    clearPlacementUI();
    updateCounts();
    draw();
  });

  toolZero.addEventListener('click', () => setTool('zero'));
  toolPole.addEventListener('click', () => setTool('pole'));

  undoBtn.addEventListener('click', () => {
    const last = lastPlacedStack.pop();
    if (!last) return;
    if (last.type === 'zero') userZeros.pop();
    else userPoles.pop();
    clearPlacementUI();
    updateCounts();
    draw();
  });

  resetBtn.addEventListener('click', () => {
    userZeros = [];
    userPoles = [];
    lastPlacedStack = [];
    clearPlacementUI();
    updateCounts();
    draw();
  });

  checkBtn.addEventListener('click', verifyPlacement);

  stabYes.addEventListener('click', () => answerStability(true));
  stabNo.addEventListener('click', () => answerStability(false));

  function answerStability(userAnswer) {
    if (!verifiedPlacement) return;

    const correct = (userAnswer === systemIsStable);
    if (correct) {
      stabFeedback.className = 'status ok';
      stabFeedback.textContent = `✅ Correto. Critério usado: estável ⇔ todos os pólos têm Re(s) < 0.`;
      stabYes.classList.toggle('good', userAnswer===true);
      stabNo.classList.toggle('good', userAnswer===false);
      stabYes.classList.remove('bad'); stabNo.classList.remove('bad');
    } else {
      stabFeedback.className = 'status bad';
      const why = systemIsStable
        ? 'Na verdade é estável porque todos os pólos estão no semiplano esquerdo.'
        : 'Na verdade é instável porque existe pelo menos um pólo com Re(s) ≥ 0.';
      stabFeedback.textContent = `❌ Incorreto. ${why}`;
      if (userAnswer) { stabYes.classList.add('bad'); stabNo.classList.remove('bad'); }
      else { stabNo.classList.add('bad'); stabYes.classList.remove('bad'); }
    }
  }

  teacherMode.addEventListener('change', draw);

  function newExercise() {
    userZeros = [];
    userPoles = [];
    lastPlacedStack = [];
    clearPlacementUI();

    const lvl = Number(levelSel.value);
    const {K} = generateSystem(lvl);

    Hdisp.textContent = buildFactorString(K, expectedZeros, expectedPoles);
    updateCounts();
    draw();
  }

  newBtn.addEventListener('click', newExercise);
  levelSel.addEventListener('change', newExercise);

  // init
  setTool('zero');
  newExercise();
})();
</script>
</body>
</html>
